using Sla.CORE;

namespace Sla.SLEIGH
{
    internal abstract class UnaryExpression : PatternExpression
    {
        private PatternExpression? unary;
        
        ~UnaryExpression()
        {
            // Delete only non-pattern values
            if (unary != (PatternExpression)null)
                PatternExpression.release(unary);
        }

        public UnaryExpression()
        {
            unary = (PatternExpression)null;
        }

        public UnaryExpression(PatternExpression u)
        {
            (unary = u).layClaim();
        }

        public PatternExpression? getUnary() => unary;

        public override TokenPattern genMinPattern(List<TokenPattern> ops)
            => new TokenPattern();

        public override void listValues(List<PatternValue> list)
        {
            (unary ?? throw new ApplicationException()).listValues(list);
        }

        public override void getMinMax(List<long> minlist, List<long> maxlist)
        {
            (unary ?? throw new ApplicationException()).getMinMax(minlist, maxlist);
        }

        public override void saveXml(TextWriter s)
        {
            // Outer tag is generated by derived classes
            (unary ?? throw new ApplicationException()).saveXml(s);
        }

        public override void restoreXml(Element el, Translate trans)
        {
            IEnumerator<Element> iter = el.getChildren().GetEnumerator();
            if (!iter.MoveNext()) throw new ApplicationException();
            unary = restoreExpression(iter.Current, trans) ?? throw new ApplicationException();
            unary.layClaim();
        }
    }
}
