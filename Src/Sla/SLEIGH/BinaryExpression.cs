using Sla.CORE;
using Sla.SLEIGH;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Sla.SLEIGH
{
    internal class BinaryExpression : PatternExpression
    {
        private PatternExpression left;
        private PatternExpression right;

        ~BinaryExpression()
        {               // Delete only non-pattern values
            if (left != (PatternExpression*)0)
                PatternExpression::release(left);
            if (right != (PatternExpression*)0)
                PatternExpression::release(right);
        }

        public BinaryExpression()
        {
            left = (PatternExpression*)0;
            right = (PatternExpression*)0;
        }

        public BinaryExpression(PatternExpression l, PatternExpression r)
        {
            (left = l)->layClaim();
            (right = r)->layClaim();
        }

        public PatternExpression getLeft() => left;

        public PatternExpression getRight() => right;

        public override TokenPattern genMinPattern(List<TokenPattern> ops) => TokenPattern();

        public override void listValues(List<PatternValue> list) 
        {
            left->listValues(list);
            right->listValues(list);
        }

        public override void getMinMax(List<intb> minlist, List<intb> maxlist) 
        {
            left->getMinMax(minlist, maxlist);
            right->getMinMax(minlist, maxlist);
        }

        public override void saveXml(TextWriter s)
        {               // Outer tag is generated by derived classes
            left->saveXml(s);
            right->saveXml(s);
        }

        public override void restoreXml(Element el, Translate trans)
        {
            List list = el->getChildren();
            List::const_iterator iter;
            iter = list.begin();
            left = PatternExpression::restoreExpression(*iter, trans);
            ++iter;
            right = PatternExpression::restoreExpression(*iter, trans);
            left->layClaim();
            right->layClaim();
        }
    }
}
